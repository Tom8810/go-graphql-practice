package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"errors"
	"fmt"
	"gorm_practice1/graph/model"
	database "gorm_practice1/internal/db"
	gormModel "gorm_practice1/internal/model"
	"strconv"

	"gorm.io/gorm"
)

// CreateBook is the resolver for the createBook field.
func (r *mutationResolver) CreateBook(ctx context.Context, input model.CreateBookInput) (*model.Book, error) {
	var modelbook *model.Book
	
	err := database.DB.Transaction(func(tx *gorm.DB) error {
		var author gormModel.Author
		if err := tx.First(&author, "id = ?", input.AuthorID).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				return fmt.Errorf("author not found: %s", input.AuthorID)
			}
		}

		authorId, _ := strconv.Atoi(input.AuthorID)

		var gormbook = &gormModel.Book{
			Title: input.Title,
			AuthorID: uint(authorId),
			Author: &gormModel.Author{
				ID: author.ID,
				Name: author.Name,
			},
		}

		if err := tx.Create(&gormbook).Error; err != nil {
			return fmt.Errorf("cannot create book: %v", err)
		}

		modelbook = &model.Book{
			ID: string(gormbook.ID),
			Title: input.Title,
			CreatedAt: gormbook.CreatedAt,
			UpdatedAt: gormbook.UpdatedAt,
			Author: &model.Author{
				ID: string(author.ID),
				Name: author.Name,
				CreatedAt: author.CreatedAt,
				UpdatedAt: author.UpdatedAt,
			},
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	return modelbook, nil
}

// UpdateBook is the resolver for the updateBook field.
func (r *mutationResolver) UpdateBook(ctx context.Context, id string, input model.UpdateBookInput) (*model.Book, error) {
	panic(fmt.Errorf("not implemented: UpdateBook - updateBook"))
}

// DeleteBook is the resolver for the deleteBook field.
func (r *mutationResolver) DeleteBook(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteBook - deleteBook"))
}

// CreateAuthor is the resolver for the CreateAuthor field.
func (r *mutationResolver) CreateAuthor(ctx context.Context, input model.CreateAuthorInput) (*model.Author, error) {
	panic(fmt.Errorf("not implemented: CreateAuthor - CreateAuthor"))
}

// Books is the resolver for the books field.
func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) {
	var books []gormModel.Book
	result := database.DB.Preload("Author").Find(&books) // 取得とbooksへのデータマッピング
	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("book not found: %v", result.Error)
		}
		return nil, fmt.Errorf("failed to fetch book: %v", result.Error)
	}
	var modelbooks []*model.Book
	for _, b := range books {
		modelbook := model.Book{
			ID:    string(b.ID),
			Title: b.Title,
			CreatedAt: b.CreatedAt,
			UpdatedAt: b.UpdatedAt,
		}
		if b.Author != nil {
			modelbook.Author = &model.Author{
				ID:   string(b.AuthorID),
				Name: b.Author.Name,
				CreatedAt: b.Author.CreatedAt,
				UpdatedAt: b.Author.UpdatedAt,
			}
		}
		modelbooks = append(modelbooks, &modelbook)
	}

	return modelbooks, nil
}

// Book is the resolver for the book field.
func (r *queryResolver) Book(ctx context.Context, id string) (*model.Book, error) {
	panic(fmt.Errorf("not implemented: Book - book"))
}

// Authors is the resolver for the authors field.
func (r *queryResolver) Authors(ctx context.Context) ([]*model.Author, error) {
	panic(fmt.Errorf("not implemented: Authors - authors"))
}

// Author is the resolver for the author field.
func (r *queryResolver) Author(ctx context.Context, id string) (*model.Author, error) {
	panic(fmt.Errorf("not implemented: Author - author"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
