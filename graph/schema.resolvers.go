package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"gorm_practice1/graph/model"
	"gorm_practice1/internal/gen"
	genmodel "gorm_practice1/internal/model"
	"strconv"
)

// CreateBook is the resolver for the createBook field.
func (r *mutationResolver) CreateBook(ctx context.Context, input model.CreateBookInput) (*model.Book, error) {
	var gqlbook *model.Book
	err := gen.Q.Transaction(func(tx *gen.Query) error {
		id, err := strconv.ParseInt(input.AuthorID, 10, 64)
		if err != nil {
			return fmt.Errorf("createBook invalid Authorid: %v", err)
		}
		user, err := gen.Q.Author.Where(gen.Q.Author.ID.Eq(id)).First() 
		if err != nil {
			return fmt.Errorf("createBook author not found: %v", err)
		}
		newBook := &genmodel.Book{
			Title: input.Title,
			AuthorID: id,
		}
		if err = gen.Q.Book.Create(newBook); err != nil {
			return fmt.Errorf("createbook failed to create book: %v", err)
		}

		gqlbook = &model.Book{
			ID: string(newBook.ID),
			Title: newBook.Title,
			CreatedAt: newBook.CreatedAt,
			UpdatedAt: newBook.UpdatedAt,
			Author: &model.Author{
				ID: string(user.ID),
				Name: user.Name,
				CreatedAt: user.CreatedAt,
				UpdatedAt: user.UpdatedAt,
			},
		}
		return nil
	})
	
	if err != nil {
		return nil, fmt.Errorf("createBook transaction not completed: %v", err)
	}

	return gqlbook, nil
}

// UpdateBook is the resolver for the updateBook field.
func (r *mutationResolver) UpdateBook(ctx context.Context, id string, input model.UpdateBookInput) (*model.Book, error) {
	panic(fmt.Errorf("not implemented: UpdateBook - updateBook"))
}

// DeleteBook is the resolver for the deleteBook field.
func (r *mutationResolver) DeleteBook(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteBook - deleteBook"))
}

// CreateAuthor is the resolver for the CreateAuthor field.
func (r *mutationResolver) CreateAuthor(ctx context.Context, input model.CreateAuthorInput) (*model.Author, error) {
	panic(fmt.Errorf("not implemented: CreateAuthor - CreateAuthor"))
}

// Books is the resolver for the books field.
func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) {
	books, err := gen.Q.Book.WithContext(ctx).Preload(gen.Book.Author).Find()
	if err != nil {
		return nil, fmt.Errorf("books: %v", err)
	}
	var gqlBooks []*model.Book
	for _, b := range books {
		gqlBook := &model.Book{
			ID:        string(b.ID),
			Title:     b.Title,
			CreatedAt: b.CreatedAt,
			UpdatedAt: b.CreatedAt,
			Author: &model.Author{
				ID:        string(b.Author.ID),
				Name:      b.Author.Name,
				CreatedAt: b.Author.CreatedAt,
				UpdatedAt: b.Author.UpdatedAt,
			},
		}
		gqlBooks = append(gqlBooks, gqlBook)
	}
	return gqlBooks, nil
}

// Book is the resolver for the book field.
func (r *queryResolver) Book(ctx context.Context, id string) (*model.Book, error) {
	panic(fmt.Errorf("not implemented: Book - book"))
}

// Authors is the resolver for the authors field.
func (r *queryResolver) Authors(ctx context.Context) ([]*model.Author, error) {
	panic(fmt.Errorf("not implemented: Authors - authors"))
}

// Author is the resolver for the author field.
func (r *queryResolver) Author(ctx context.Context, id string) (*model.Author, error) {
	panic(fmt.Errorf("not implemented: Author - author"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
